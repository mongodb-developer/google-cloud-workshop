---
sidebar_position: 1
---

import useBaseUrl from '@docusaurus/useBaseUrl';

# Create an Atlas GraphQL API

In this section, we are going to get set up with our first Atlas App Services application, ready for using GraphQL.

## Create an Atlas App Services application

1. Start by navigating to the **App Services** tab.

    <img
        alt="Atlas navigation bar highlighting the 'App Services' tab"
        src={useBaseUrl('/img/chapter-2-app-services/app-services-tab.png')}
    />

1. You’ll be prompted to select a starter template. Let’s go with the **Build your own App** option that’s already selected. Click the **Next** button. 
1. Next, you need to configure your application.
    - **Data Source**: Since we have created a single cluster, Atlas already linked it to our application.
    - **Application Name**: Let’s give our application a meaningful name such as **Bakery**.
    - **App Deployment Model**: Change the deployment to **Single Region** and select the region closest to your physical location.
1. Click the **Create App Service** button to create your first App Services application!

## Configure rules

We want to add some rules to control our app’s access to our data.

1. At the end of the previous section, after creating your application, it will have taken you to it in your browser. On the left, under the **Data Access** heading, select **Rules**.

    <img
        alt="Left-hand navigation panel highlighting the 'Rules' tab"
        src={useBaseUrl('/img/chapter-2-app-services/rules-tab.png')}
        width="200"
    />

1. We will need to make two rules—one for each of our collections.
    - Select the **cakes** collection, select the **readAll** preset, and then click **Add preset role**.
    - A popup will appear talking about **Save and Deploy**. You can just click through this and leave it as it is.

1. Select the **comments** collection from the left, and this time, apply the **readAndWriteAll** rule.

1. Since we have made changes to the app by adding these rules, we need to deploy those changes. This **Review Draft & Deploy** step is on by default, to protect us from making changes unintentionally.
    - Click the **Review Draft & Deploy** button in the blue banner across the top of your screen.
    - This will show the rules we have applied, as the system has added them into a new `rules.json` file. Simply scroll down to the bottom of the window and click **Deploy**.

## Generate a schema

GraphQL requires us to have a schema defined for building up queries, so in this section, we will generate a schema for both our cakes and comments collections.

1. Click **Schema** on the left, just below where you clicked **Rules** in Step 1 of the last section.

1. Select the **cakes** collection. App Services will see that you already have data that it can generate a schema from, so go ahead and click **Generate a Schema**.

1. Leave the default sample size and click **Generate schema from sampling**.

1. A JSON schema will be generated, matching the field names to their data types. At the top of the browser window, click **Save Draft** to save this new schema.

1. We now want to create a schema for our **comments** collection. This time, we’ll write the schema instead of generating it. Click **Generate a Schema** and then select **or, skip and manually define your schema** at the bottom of the window.

    <img
        alt="Generate a Schema window with the 'or, skip and manually define your schema' option highlighted"
        src={useBaseUrl('/img/chapter-2-app-services/write-your-schema.png')}
        width="400"
    />

1. Paste the following JSON schema into the box and click **Save Draft** to persist the change.

    ```json
    {
        "title": "comment",
        "properties": {
            "_id": {
                "bsonType": "objectId"
            },
            "cakeId": {
                "bsonType": "objectId"
            },
            "date": {
                "bsonType": "date"
            },
            "name": {
                "bsonType": "string"
            },
            "text": {
                "bsonType": "string"
            }
        }
    }
    ```

1. We now need to define a relationship between our two collections so that the comment document understands `cakeId`. Click **Add a relationship** and set it to the following before clicking **Add**:
    - Parent Field: **cakeId - objectId**
    - Linked Database: **Bakery**
    - Linked Collection: **cakes**
    - Linked Field: **_id - objectId**

:::caution
If you see the following error while adding a relationship, you might have forgotten to save your schema draft:
> You must define a schema with a valid properties object for this collection before adding a relationship.

Locate the **Save Draft** button in the top right corner of the screen and click it to persist your schema.
:::

1. Click **Save Draft** to persist the relationship you just created. Then, click **Review Draft & Deploy** at the top of the browser window, to deploy both our new schemas for our application.

1. Click **Deploy** in the modal that pops up.

## Query data with GraphQL

Now that we have the schemas in place, it’s time to run our first query to check it all works!

1. Click **GraphQL** from the left side menu, under the **Build** heading.

    <img
        alt="Left-hand navigation panel highlighting the 'GraphQL' tab"
        src={useBaseUrl('/img/chapter-2-app-services/graphql-tab.png')}
        width="300"
    />

1. Replace the comments and sample query inside the playground with the following query, which requests the name and description from our cakes collection:

    ```graphql
    query {
        cakes {
            name
            description
        }
    }
    ```

1. Click the play button at the top to run your query, and see your cakes document returned on the right.  

    <img
        alt="GraphQL request with the cakes query (on the left) and the returned result (on the right)"
        src={useBaseUrl('/img/chapter-2-app-services/graphiql.png')}
    />
